	Macros are words defined in python and are run at compile time.

	Each macro accepts rest of words in the line and returns list of
	words to replace original with.

	Function macro searches for macro and executes it. If no macro found,
	returns None.

=macro
-def trymacro(l,r):
-	f=trymacro.all.get(l)
-	if f: return f(r)
-	return
-trymacro.all={}

	Macros are defined with @macro decorator. Macro name is expected to
	be either have 'm_' prefix or have docstring with real name like

		def newmacro(l):
			";werid-name"
			...

-def macro(f,n=None):
-	if n: name=n
-	elif f.__doc__: name=f.__doc__
-	else: name=f.__name__[2:]
-	trymacro.all[name]=f


		Parametric macros

	Parametric macros are written in a form: name[.... Everything past
	square bracket are up to macro's interpretation.

	Examples are working with data: rep[name word] executes word over name
	data; @[name field] retrieves field from data name with a register.

=macro
-class ParametricMacroNotDefined(Exception):
-	pass

-def parametric_macro(l):
-	w,r=l.split('[',1)
-	f=trymacro.all.get(w)
-	if not f: raise ParametricMacroNotDefined(repr(w))
-	return f(r)

		Data parametric macros

	rep macro is rep[name word] executes word over name data.

-@macro
-def macro_rep(l):
-	"rep"
-	l,r=l.split(']',1)
-	n,w=l.split();
-	o("\tfor(lang_internal_a=0;lang_internal_a<%u;lang_internal_a++) { lang_%s(); }",compile_data.data[n].size,mangle(w))
-	return r

-@macro
-def macro_at(l):
-	"@"
-	l,r=l.split(']',1)
-	n,f=l.split()
-	index='lang_internal_a' if compile_data.data[n].size>1 else '0'
-	o("\tlang_internal_push(lang_data_%s[%s].%s);",mangle(n),index,mangle(f))
-	return r

-@macro
-def macro_set(l):
-	"!"
-	l,r=l.split(']',1)
-	n,f=l.split()
-	index='lang_internal_a' if compile_data.data[n].size>1 else '0'
-	o("\tlang_data_%s[%s].%s=lang_internal_pop();",mangle(n),index,mangle(f))
-	return r

		Core


	The core of forth is data stack and addressing register.

=stack
-c #include <assert.h>
-c #include <stdint.h>
-c typedef uint64_t CELL;
-c typedef int64_t SCELL;
-c static CELL lang_internal_stack[16];
-c static CELL *lang_internal_tos=lang_internal_stack-1;
-c static CELL lang_internal_a;
-c void lang_internal_push(CELL x) { lang_internal_tos++; assert(lang_internal_tos<lang_internal_stack+16); *lang_internal_tos=x; }
-c CELL lang_internal_pop(void) { assert(lang_internal_tos>=lang_internal_stack); CELL x=*lang_internal_tos--; return x; }




	Forth allow many names which are not valid C identifiers.
	We convert everything not in [a-z] into _HEXCHARCODE_. So
	word 1+ will become _31__2B_

=mangle
-def mangle_char(x):
-	if x not in "abcdefghijklmnopqrstuvwxyz": return "_%02X_"%(ord(x),)
-	return x

-def mangle(name):
-	return ''.join([mangle_char(x) for x in name])




	All data is stored in database fashion. For each type
	of data schema is defined, which also defines words to
	access this data.

	To create array of 128 planets use:

		data planet 128 x y z radius name

	They then can be accessed by setting index into register
	'a' and using syntax planet@radius for retreiving field
	value and planet!radius for storing.

=data
-class R():
-	def __init__(_,**kw):
-		for x,y in kw.items(): setattr(_,x,y)

-def compile_data(rest):
-	args=rest.split()
-	name,size=args[:2]
-	size=int(size)
-	fields=args[2:]
-	o("struct lang_data_%s {",mangle(name))
-	for x in fields:
-		if ':' in x:
-			x,t=x.split(':')
-			o("\t%s %s;",t,mangle(x))
-		else:
-			o("\tCELL %s;",mangle(x))
-	o("} lang_data_%s[%u];",mangle(name),size)

-	compile_data.data[name]=R(size=size,fields=fields)

-compile_data.data={}



	Conditionals are simple ?0; which pops value and exists if it is zero and ?; which
	exists if not zero.

=cond
-@macro
-def returnonzero(l):
-	"?0;"
-	o('if(lang_internal_pop()==0) return;')
-	return l

-@macro
-def returnonnonzero(l):
-	"?;"
-	o('if(lang_internal_pop()) return;')
-	return l

-@macro
-def returnonpositive(l):
-	"?+;"
-	o('if(((SCELL)lang_internal_pop())>0) return;')
-	return l

-@macro
-def returnonnegative(l):
-	"?-;"
-	o('if(((SCELL)lang_internal_pop())<0) return;')
-	return l

	Output is initially accumulated as a list of strings.
	We also have special case for function prototypes.


=coutput
-def o(x,*a,**kw):
-	w=o.code
-	if kw:
-		w=o.proto
-	if a:
-		w.append(x%a)
-	else:
-		w.append(x)
-o.code=[]
-o.proto=[]


	First we load all files into memory as lines

=load
-source=[]

-class posstr(str):
-	def __new__(c,s,name,line):
-		o=str.__new__(c,s)
-		o.name=name
-		o.line=line
-		return o

-class CompileError(BaseException):
-	def __init__(_,l,e):
-		_.l=l
-		_.e=e

-def load_all(l):
-	for x in l:
-		line=0
-		for y in open(x):
-			source.append(posstr(y,x,line))
-			line+=1


	On a first pass we execute all user's pythonic code:

=extendpass
-def extendpass():
-	global source
-	block=None
-	for i in range(len(source)):
-		l=source[i]
-		t=l.split(None,1)
-		if not t: continue
-		if block is None:
-			if t[0]=='extend':
-				block=[]
-				source[i]=None
-		else:
-			if t[0]=='end':
-				exec(''.join(block),globals())
-				block=None
-				source[i]=None
-			else:
-				block.append(l)
-				source[i]=None
-	source=[x for x in source if x is not None]

	Than we compile all 'c' code.

=cpass
-def cpass():
-	global source
-	for i in range(len(source)):
-		l=source[i]
-		try:
-			t=l.split(None,1)
-			if not t: continue
-			name,rest=t
-			if name=='c':
-				compile_c(rest)
-				source[i]=None
-		except Exception as e:
-			raise CompileError(l,e)
-	source=[x for x in source if x is not None]


	On a next pass we evaluate all data lines:

=datapass
-def datapass():
-	global source
-	for i in range(len(source)):
-		l=source[i]
-		t=l.split(None,1)
-		if not t: continue
-		name,rest=t
-		if name=='data':
-			compile_data(rest)
-			source[i]=None
-	source=[x for x in source if x is not None]


	And finally, we compile code

=codepass
-def codepass():
-	for l in source:
-		try:
-			compile_line(l)
-		except Exception as e:
-			raise CompileError(l,e)




	Initially it was written as illiterate code.

=>main.py
-from sys import argv

>mangle
>macro
>cond
>load
>extendpass
>cpass
>datapass
>codepass

>coutput

-class Pos: pass

-pos=Pos()

>data

-def compile_def(name,rest):
-	o("static void lang_%s(void) { _tailcall:;",mangle(name))
-	o("static void lang_%s(void);",mangle(name),proto=1)

-	while rest:
-		rest=rest.lstrip()
-		orig=rest
-		s=rest.split(None,1)
-		if not s: break
-		word=s[0]
-		rest=s[1] if len(s)>1 else ''
-		l=trymacro(word,rest)
-		if l is not None: rest=l
-		elif '[' in word: rest=parametric_macro(orig)
-		elif word.isdigit(): o("\tlang_internal_push(%uu);",int(word))
-		elif word[0]=='-' and word[1:].isdigit(): o("\tlang_internal_push(%d);",int(word))
-		elif word==name and not rest:
-			o("\tgoto _tailcall;")
-		else: o("\tlang_%s();",mangle(word))
-	o("}")

-def compile_c(l):
-	o(l)

-def compile_cdef(rest):
-	name,code=rest.split(None,1)
-	o("static void lang_%s(void) {",mangle(name))
-	o("static void lang_%s(void);",mangle(name),proto=1)
-	o("\t"+code)
-	o("}")
-	

-def compile_line(l):
-	t=l.split(None,1)
-	if not t: return

-	name,rest=t

-	if name=='cdef': compile_cdef(rest)
-	else: compile_def(name,rest)

-userpass=[]
-def regpass(f):
-	userpass.append(f)

-err=None
-load_all(argv[2:])
-try:
-	extendpass()
-	for x in userpass: x()
-	cpass()
-	datapass()
-	codepass()
-except CompileError as s:
-	if type(s.l)==posstr:
-		print('\nERROR: %s:%s: %s'%(s.l.name,s.l.line,s.l))
-	else:
-		print('\nERROR: generated: %s'%(s.l,))
-	err=s
-if err: raise err.e

-open(argv[1],'w').write("\n".join(o.proto+o.code))

Stack operations

=stackops
-cdef dup CELL x=lang_internal_pop(); lang_internal_push(x); lang_internal_push(x);
-cdef swap CELL x=lang_internal_pop(); CELL y=lang_internal_pop(); lang_internal_push(x); lang_internal_push(y);
-cdef drop lang_internal_pop();

Register A holds index during rep.

=regs
-cdef a lang_internal_push(lang_internal_a);
-cdef a! lang_internal_a=lang_internal_pop();
-cdef a++ lang_internal_a++;


=>runtime.lang
>stack
>stackops
>regs



Bit operations

=bitops
-cdef and lang_internal_push(lang_internal_pop()&lang_internal_pop());
-cdef or lang_internal_push(lang_internal_pop()|lang_internal_pop());
-cdef xor lang_internal_push(lang_internal_pop()^lang_internal_pop());
-cdef shl CELL x=lang_internal_pop(); lang_internal_push(lang_internal_pop()<<x);
-cdef shr CELL x=lang_internal_pop(); lang_internal_push(lang_internal_pop()>>x);

Arithmetics

=arith
-cdef *	lang_internal_push(((SCELL)lang_internal_pop())*((SCELL)lang_internal_pop()));
-cdef +	lang_internal_push(lang_internal_pop()+lang_internal_pop());
-cdef -	CELL a=lang_internal_pop(); CELL b=lang_internal_pop(); lang_internal_push(b-a);
-cdef /	SCELL x=lang_internal_pop(); lang_internal_push(((SCELL)lang_internal_pop())/x);
-cdef */ SCELL d=lang_internal_pop(); SCELL m=lang_internal_pop(); signed __int128 z=(SCELL)lang_internal_pop(); z*=m; lang_internal_push(z/d);

Trigonometry. For trigonometry we use 64-bitians, 1<<64 of them are full rotation. For -1..1 values
we use 9223372036854775807 as 1.

=trig
-trig1 9223372036854775807
-cdef cos SCELL x=9223372036854775807*cos(2*M_PI*(lang_internal_pop()/18446744073709551616.0)); lang_internal_push(x);
-cdef sin SCELL x=9223372036854775807*sin(2*M_PI*(lang_internal_pop()/18446744073709551616.0)); lang_internal_push(x);


=>math.lang
-c #include <math.h>
>bitops
>arith
>trig

=output
-cdef print printf("%lu ",lang_internal_pop());
-cdef sprint printf("%ld ",(SCELL)lang_internal_pop());
-cdef cr printf("\n");

=time
-cdef time64 struct timeval t; gettimeofday(&t,0); lang_internal_push((t.tv_sec<<32)|t.tv_usec);


=>lib.lang
-c #include <stdio.h>
-c #include <sys/time.h>
>output
>time


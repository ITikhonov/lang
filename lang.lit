	Macros are words defined in python and are run at compile time.

	Each macro accepts rest of words in the line and returns list of
	words to replace original with.

	Function macro searches for macro and executes it. If no macro found,
	returns None.

=macro
-def trymacro(l):
-	f=trymacro.all.get(l[0])
-	if f: return f(l[1:])
-	return
-trymacro.all={}

	Macros are defined with @macro decorator. Macro name is expected to
	be either have 'm_' prefix or have docstring with real name like

		def newmacro(l):
			";werid-name"
			...

-def macro(f,n=None):
-	if n: name=n
-	elif f.__doc__: name=f.__doc__
-	else: name=f.__name__[2:]
-	trymacro.all[name]=f




	The core of forth is data stack and addressing register.

=stack
-c #include <stdint.h>
-c typedef uint64_t CELL;
-c typedef int64_t SCELL;
-c static CELL lang_internal_stack[16];
-c static CELL *lang_internal_tos=lang_internal_stack-1;
-c static CELL lang_internal_a;
-c void lang_internal_push(CELL x) { lang_internal_tos++; *lang_internal_tos=x; }
-c CELL lang_internal_pop(void) { CELL x=*lang_internal_tos--; return x; }




	Forth allow many names which are not valid C identifiers.
	We convert everything not in [a-z] into _HEXCHARCODE_. So
	word 1+ will become _31__2B_

=mangle
-def mangle_char(x):
-	if x not in "abcdefghijklmnopqrstuvwxyz": return "_%02X_"%(ord(x),)
-	return x

-def mangle(name):
-	return ''.join([mangle_char(x) for x in name])




	All data is stored in database fashion. For each type
	of data schema is defined, which also defines words to
	access this data.

	To create array of 128 planets use:

		data planet 128 x y z radius name

=data
-def compile_data(rest):
-	args=rest.split()
-	name,size=args[:2]
-	size=int(size)
-	fields=args[2:]
-	o("struct lang_data_%s {",mangle(name))
-	for x in fields:
-		o("\tCELL %s;",mangle(x))
-	o("} lang_data_%s[%u];",mangle(name),size)

	To access planet field use:

		planet@radius ( -- v )
		planet!radius ( v -- )

	For data with size 1 the only record is used always. For
	other sizes, internal register 'a' used.

-	if size==1: index="0"
-	else: index="lang_internal_a"

-	for x in fields:
-		o("void lang_%s(void) { lang_internal_push(lang_data_%s[%s].%s); }",mangle(name+'@'+x),mangle(name),index,mangle(x))
-		o("void lang_%s(void) { lang_data_%s[%s].%s=lang_internal_pop(); }",mangle(name+'!'+x),mangle(name),index,mangle(x))

	To iterate over all planets use:

		planet.each word
		word ( -- )
-	macro(lambda l: template_data_rep(size,l),name+'.rep')

-def template_data_rep(size,l):
-	o("\tfor(lang_internal_a=0;lang_internal_a<%u;lang_internal_a++) { lang_%s(); }",size,l[0])
-	return l[1:]




	Conditional is simple ?; which exists if stack is zero.

=cond
-@macro
-def returnonzero(l):
-	"?;"
-	o('if(lang_internal_pop()==0) return;')
-	return l


	Initially it was written as illiterate code.

=>main.py
-from sys import argv

>mangle
>macro
>cond

-def o(x,*a):
-	if a:
-		o.code.append(x%a)
-	else:
-		o.code.append(x)
-o.code=[]

-class Pos: pass

-pos=Pos()

>data

-def compile_def(name,rest):
-	words=rest.split()
-	o("static void lang_%s(void) {",mangle(name))
-	while words:
-		l=trymacro(words)
-		if l is not None: words=l
-		elif words[0].isdigit(): o("\tlang_internal_push(%uu);",int(words.pop(0)))
-		else: o("\tlang_%s();",mangle(words.pop(0)))
-	o("}")

-def compile_c(l):
-	o(l)

-def compile_cdef(rest):
-	name,code=rest.split(None,1)
-	o("static void lang_%s(void) {",mangle(name))
-	o("\t"+code)
-	o("}")
-	

-def compile_line(l):
-	t=l.split(None,1)
-	if not t: return

-	name,rest=t

-	if name=='c': compile_c(rest)
-	elif name=='data': compile_data(rest)
-	elif name=='cdef': compile_cdef(rest)
-	else: compile_def(name,rest)

-def compile_file(name):
-	pos.name=name
-	lines=open(name).readlines()
-	for i in range(len(lines)):
-		pos.line=i+1
-		pos.str=lines[i]
-		compile_line(lines[i])

-def compile_all(t,l):
-	for x in l:
-		compile_file(x)
-	open(t,'w').write("\n".join(o.code))

-try:
-	compile_all(argv[1],argv[2:])
-except:
-	print()
-	print('Error at %s:%u'%(pos.name,pos.line))
-	print('\t| %s'%(pos.str,))
-	raise

-print(trymacro.all)


Stack operations

=stackops
-cdef dup CELL x=lang_internal_pop(); lang_internal_push(x); lang_internal_push(x);
-cdef swap CELL x=lang_internal_pop(); CELL y=lang_internal_pop(); lang_internal_push(x); lang_internal_push(y);
-cdef drop lang_internal_pop();

Register A holds index during rep.

=regs
-cdef a lang_internal_push(lang_internal_a);
-cdef a! lang_internal_a=lang_internal_pop();


=>runtime.lang
>stack
>stackops
>regs



Bit operations

=bitops
-cdef and lang_internal_push(lang_internal_pop()&lang_internal_pop());
-cdef or lang_internal_push(lang_internal_pop()|lang_internal_pop());
-cdef xor lang_internal_push(lang_internal_pop()^lang_internal_pop());
-cdef shl CELL x=lang_internal_pop(); lang_internal_push(lang_internal_pop()<<x);
-cdef shr CELL x=lang_internal_pop(); lang_internal_push(lang_internal_pop()>>x);

Arithmetics

=arith
-cdef *	lang_internal_push(((SCELL)lang_internal_pop())*((SCELL)lang_internal_pop()));
-cdef +	lang_internal_push(lang_internal_pop()+lang_internal_pop());
-cdef /	SCELL x=lang_internal_pop(); lang_internal_push(((SCELL)lang_internal_pop())/x);
-cdef */ SCELL d=lang_internal_pop(); SCELL m=lang_internal_pop(); signed __int128 z=(SCELL)lang_internal_pop(); z*=m; lang_internal_push(z/d);

Trigonometry. For trigonometry we use 64-bitians, 1<<64 of them are full rotation. For -1..1 values
we use 9223372036854775807 as 1.

=trig
-trig1 9223372036854775807
-cdef cos SCELL x=9223372036854775807*cos(2*M_PI*(lang_internal_pop()/18446744073709551616.0)); lang_internal_push(x);
-cdef sin SCELL x=9223372036854775807*sin(2*M_PI*(lang_internal_pop()/18446744073709551616.0)); lang_internal_push(x);


=>math.lang
-c #include <math.h>
>bitops
>arith
>trig

=output
-cdef print printf("%lu ",lang_internal_pop());
-cdef sprint printf("%ld ",(SCELL)lang_internal_pop());
-cdef cr printf("\n");

=time
-cdef time64 struct timeval t; gettimeofday(&t,0); lang_internal_push((t.tv_sec<<32)|t.tv_usec);


=>lib.lang
-c #include <stdio.h>
-c #include <sys/time.h>
>output
>time

